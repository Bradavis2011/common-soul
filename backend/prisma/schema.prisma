generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  password    String?  // Optional for OAuth users
  userType    String
  isVerified  Boolean  @default(false)
  isSuspended Boolean  @default(false)
  suspensionReason String?
  suspendedAt DateTime?
  isBanned    Boolean  @default(false)
  bannedAt    DateTime?
  banReason   String?
  warningCount Int     @default(0)
  lastWarningAt DateTime?

  // OAuth fields
  provider    String?  // 'google', 'facebook', 'email'
  providerId  String?  // OAuth provider user ID
  providerData String? // JSON string of additional OAuth data

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  profile UserProfile?
  services Service[]
  customerBookings Booking[] @relation("CustomerBookings")
  healerBookings Booking[] @relation("HealerBookings")
  customerReviews Review[] @relation("CustomerReviews")
  healerReviews Review[] @relation("HealerReviews")
  customerConversations Conversation[] @relation("CustomerConversations")
  healerConversations   Conversation[] @relation("HealerConversations")
  sentMessages         Message[]      @relation("SentMessages")
  availability         HealerAvailability[]
  reportsCreated       Report[]       @relation("ReportsCreated")
  reportsReceived      Report[]       @relation("ReportsReceived")
  
  // Forum relations
  forumPosts           ForumPost[]    @relation("ForumPostAuthor")
  forumComments        ForumComment[] @relation("ForumCommentAuthor")
  forumPostLikes       ForumPostLike[]
  forumCommentLikes    ForumCommentLike[]
  
  @@map("users")
}

model UserProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  firstName   String
  lastName    String
  bio         String?
  phone       String?
  location    String?
  avatarUrl   String?
  dateOfBirth DateTime?
  website     String?
  timezone    String?
  isProfileComplete Boolean @default(false)
  profileCompletionScore Int @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  healerProfile HealerProfile?
  customerProfile CustomerProfile?
  
  @@map("user_profiles")
}

model HealerProfile {
  id              String   @id @default(cuid())
  profileId       String   @unique
  specialties     String?  // JSON string of specialties array
  hourlyRate      Float?
  yearsExperience Int?
  certificationsData  String?  // JSON string of certifications array
  educationData       String?  // Education background
  languages       String?  // JSON string of languages spoken
  sessionTypes    String?  // JSON string of session types offered
  availability    String?  // JSON string of availability schedule
  consultationFee Float?   // Initial consultation fee
  sessionDuration String?  // Default session duration
  cancellationPolicy String? // Cancellation policy
  paymentMethods  String?  // JSON string of accepted payment methods
  stripeConnectId String?  // Stripe Connect account ID for receiving payments
  profileBanner   String?  // Banner image URL
  socialLinks     String?  // JSON string of social media links
  testimonials    String?  // JSON string of testimonials
  isVerified      Boolean  @default(false)
  isActive        Boolean  @default(true)
  lastActiveAt    DateTime @default(now())
  // Quality metrics for trust system
  averageRating   Float?   @default(0)
  totalReviews    Int      @default(0)
  responseRate    Float?   @default(0) // Percentage of messages replied to
  cancellationRate Float?  @default(0) // Percentage of bookings cancelled
  noShowRate      Float?   @default(0) // Percentage of sessions missed
  completedSessions Int    @default(0)
  totalBookings   Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt @default(now())
  
  profile UserProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  // Credential verification relationships
  documents         HealerDocument[]
  certifications    HealerCertification[]
  education         HealerEducation[]
  experience        HealerExperience[]
  references        HealerReference[]
  backgroundCheck   HealerBackgroundCheck?
  verificationChecklist HealerVerificationChecklist?
  
  @@map("healer_profiles")
}

model CustomerProfile {
  id                String   @id @default(cuid())
  profileId         String   @unique
  interests         String?  // JSON string of spiritual interests array
  preferredLocation String?
  preferredSessionTypes String? // JSON string of preferred session types
  goals             String?  // Spiritual/healing goals
  previousExperience String? // Previous spiritual healing experience
  healthConditions  String?  // Relevant health conditions (optional)
  availabilityPreferences String? // JSON string of preferred times
  budgetRange       String?  // Budget range for sessions
  communicationStyle String? // Preferred communication style
  sessionFrequency  String?  // How often they want sessions
  preferences       String?  // JSON string of other preferences
  referralSource    String?  // How they heard about the platform
  emergencyContact  String?  // Emergency contact information
  consentToContact  Boolean  @default(true)
  marketingOptIn    Boolean  @default(false)
  lastBookingAt     DateTime?
  totalSessions     Int      @default(0)
  favoriteHealers   String?  // JSON string of favorite healer IDs
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  profile UserProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  @@map("customer_profiles")
}

model Service {
  id          String      @id @default(cuid())
  healerId    String
  title       String
  description String
  duration    Int         // Duration in minutes
  price       Float
  category    String
  imageUrl    String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  healer User @relation(fields: [healerId], references: [id], onDelete: Cascade)
  bookings Booking[]
  reviews Review[]
  
  @@map("services")
}

model Booking {
  id          String      @id @default(cuid())
  customerId  String
  healerId    String
  serviceId   String
  scheduledAt DateTime
  duration    Int         // Duration in minutes
  totalPrice  Float
  status      String @default("PENDING")
  notes       String?
  customerNotes String?
  healerNotes String?
  cancellationReason String?
  cancelledAt DateTime?
  completedAt DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  customer User @relation(name: "CustomerBookings", fields: [customerId], references: [id], onDelete: Cascade)
  healer   User @relation(name: "HealerBookings", fields: [healerId], references: [id], onDelete: Cascade)
  service  Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  review   Review?
  conversation Conversation?
  payment Payment?
  
  @@map("bookings")
}

model Review {
  id          String   @id @default(cuid())
  customerId  String
  healerId    String
  serviceId   String?
  bookingId   String?  @unique
  rating      Int      // 1-5 stars
  title       String?
  comment     String?
  isVerified  Boolean  @default(false) // True if from completed booking
  isPublic    Boolean  @default(true)
  response    String?  // Healer response
  respondedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  customer User    @relation(name: "CustomerReviews", fields: [customerId], references: [id], onDelete: Cascade)
  healer   User    @relation(name: "HealerReviews", fields: [healerId], references: [id], onDelete: Cascade)
  service  Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  booking  Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)

  @@map("reviews")
}


model Payment {
  id              String        @id @default(cuid())
  bookingId       String        @unique
  amount          Float         // Total amount paid
  currency        String        @default("USD")
  status          String @default("PENDING")
  paymentMethod   String
  stripePaymentId String?       // Stripe payment intent ID
  stripeSessionId String?       // Stripe session ID for checkout
  platformFee     Float         @default(0) // Platform commission
  healerAmount    Float         // Amount after platform fee
  paymentDate     DateTime?
  refundAmount    Float?        @default(0)
  refundDate      DateTime?
  metadata        String?       // JSON string for additional data
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  @@map("payments")
}


model Conversation {
  id            String    @id @default(cuid())
  customerId    String
  healerId      String
  bookingId     String?   @unique // Optional: link to specific booking
  lastMessageAt DateTime  @default(now())
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  customer User    @relation(name: "CustomerConversations", fields: [customerId], references: [id], onDelete: Cascade)
  healer   User    @relation(name: "HealerConversations", fields: [healerId], references: [id], onDelete: Cascade)
  booking  Booking? @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  messages Message[]
  
  @@unique([customerId, healerId])
  @@map("conversations")
}

model Message {
  id             String      @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  messageType    String @default("TEXT")
  attachmentUrl  String?     // For images, files, etc.
  isRead         Boolean     @default(false)
  readAt         DateTime?
  isEdited       Boolean     @default(false)
  editedAt       DateTime?
  originalContent String?    // Store original content if edited
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(name: "SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  
  @@map("messages")
}

model HealerAvailability {
  id              String   @id @default(cuid())
  healerId        String
  dayOfWeek       Int      // 0 = Sunday, 1 = Monday, etc.
  isAvailable     Boolean  @default(false)
  startTime       String   // Time in HH:MM:SS format
  endTime         String   // Time in HH:MM:SS format
  breakStartTime  String?  // Optional break start time
  breakEndTime    String?  // Optional break end time
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  healer User @relation(fields: [healerId], references: [id], onDelete: Cascade)
  
  @@unique([healerId, dayOfWeek])
  @@map("healer_availability")
}

model Report {
  id          String   @id @default(cuid())
  reporterId  String
  targetType  String   // USER, SERVICE, REVIEW, MESSAGE
  targetId    String
  targetUserId String? // For linking to the user being reported
  reason      String   // SPAM, INAPPROPRIATE, FRAUD, NO_SHOW, UNPROFESSIONAL, SAFETY, OTHER
  details     String?
  status      String   @default("PENDING") // PENDING, REVIEWED, RESOLVED, DISMISSED
  resolution  String?
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?
  
  reporter    User @relation(name: "ReportsCreated", fields: [reporterId], references: [id], onDelete: Cascade)
  targetUser  User? @relation(name: "ReportsReceived", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@map("reports")
}

// Credential Verification Models

model HealerDocument {
  id                 String   @id @default(cuid())
  healerProfileId    String
  documentType       String   // 'CERTIFICATION', 'LICENSE', 'EDUCATION', 'INSURANCE', 'RESUME', 'REFERENCE'
  documentName       String
  fileUrl            String
  fileSize           Int?
  mimeType           String?
  verificationStatus String   @default("PENDING") // 'PENDING', 'VERIFIED', 'REJECTED', 'EXPIRED'
  verificationNotes  String?
  verifiedBy         String?  // Admin ID who verified
  verifiedAt         DateTime?
  expiresAt          DateTime? // For licenses/certifications with expiry
  uploadedAt         DateTime @default(now())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  healerProfile HealerProfile @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)
  certifications HealerCertification[]
  education      HealerEducation[]

  @@map("healer_documents")
}

model HealerCertification {
  id                   String   @id @default(cuid())
  healerProfileId      String
  certificationName    String
  issuingOrganization  String
  certificationNumber  String?
  issueDate            DateTime?
  expiryDate           DateTime?
  verificationUrl      String?  // Link to verify with issuing org
  documentId           String?  // Link to uploaded document
  status               String   @default("ACTIVE") // 'ACTIVE', 'EXPIRED', 'REVOKED'
  verificationStatus   String   @default("PENDING")
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  healerProfile HealerProfile    @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)
  document      HealerDocument?  @relation(fields: [documentId], references: [id], onDelete: SetNull)

  @@map("healer_certifications")
}

model HealerEducation {
  id                 String   @id @default(cuid())
  healerProfileId    String
  institutionName    String
  degreeType         String?  // 'CERTIFICATE', 'DIPLOMA', 'BACHELOR', 'MASTER', 'DOCTORATE', 'OTHER'
  degreeTitle        String
  fieldOfStudy       String?
  startDate          DateTime?
  endDate            DateTime?
  graduationStatus   String   @default("COMPLETED") // 'COMPLETED', 'IN_PROGRESS', 'INCOMPLETE'
  gpa                String?
  honors             String?
  documentId         String?  // Link to diploma/transcript
  verificationStatus String   @default("PENDING")
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  healerProfile HealerProfile   @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)
  document      HealerDocument? @relation(fields: [documentId], references: [id], onDelete: SetNull)

  @@map("healer_education")
}

model HealerExperience {
  id                        String   @id @default(cuid())
  healerProfileId           String
  organizationName          String
  positionTitle             String
  employmentType            String?  // 'FULL_TIME', 'PART_TIME', 'CONTRACT', 'VOLUNTEER', 'SELF_EMPLOYED'
  startDate                 DateTime
  endDate                   DateTime?
  isCurrent                 Boolean  @default(false)
  description               String?
  keyAchievements           String?
  location                  String?
  verificationContactName   String?
  verificationContactEmail  String?
  verificationContactPhone  String?
  verificationStatus        String   @default("PENDING")
  verifiedAt                DateTime?
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  healerProfile HealerProfile @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)

  @@map("healer_experience")
}

model HealerReference {
  id                String   @id @default(cuid())
  healerProfileId   String
  referenceType     String   // 'PROFESSIONAL', 'ACADEMIC', 'CLIENT', 'MENTOR'
  contactName       String
  contactTitle      String?
  organization      String?
  relationship      String
  email             String
  phone             String?
  yearsKnown        Int?
  referenceStatus   String   @default("PENDING") // 'PENDING', 'CONTACTED', 'VERIFIED', 'DECLINED', 'UNREACHABLE'
  referenceNotes    String?
  contactedAt       DateTime?
  respondedAt       DateTime?
  verificationScore Int?     // 1-10 rating from reference
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  healerProfile HealerProfile @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)

  @@map("healer_references")
}

model HealerBackgroundCheck {
  id                String   @id @default(cuid())
  healerProfileId   String   @unique
  checkType         String   // 'CRIMINAL', 'IDENTITY', 'EMPLOYMENT', 'EDUCATION', 'PROFESSIONAL_LICENSE'
  provider          String?  // Background check service provider
  providerRequestId String?
  status            String   @default("PENDING") // 'PENDING', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'DECLINED'
  result            String?  // 'CLEAR', 'FLAGGED', 'DISQUALIFIED'
  resultDetails     String?  // JSON with detailed findings
  initiatedAt       DateTime @default(now())
  completedAt       DateTime?
  expiresAt         DateTime? // When check needs renewal
  cost              Float?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  healerProfile HealerProfile @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)

  @@map("healer_background_checks")
}

model HealerVerificationChecklist {
  id                      String   @id @default(cuid())
  healerProfileId         String   @unique
  identityVerified        Boolean  @default(false)
  certificationsVerified  Boolean  @default(false)
  educationVerified       Boolean  @default(false)
  experienceVerified      Boolean  @default(false)
  referencesVerified      Boolean  @default(false)
  backgroundCheckCompleted Boolean @default(false)
  interviewCompleted      Boolean  @default(false)
  insuranceVerified       Boolean  @default(false)
  portfolioReviewed       Boolean  @default(false)
  overallStatus           String   @default("PENDING") // 'PENDING', 'IN_REVIEW', 'APPROVED', 'REJECTED'
  adminNotes              String?
  rejectedReason          String?
  approvedBy              String?
  approvedAt              DateTime?
  nextReviewDate          DateTime?
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  healerProfile HealerProfile @relation(fields: [healerProfileId], references: [id], onDelete: Cascade)

  @@map("healer_verification_checklist")
}

// Forum Models

model ForumPost {
  id            String   @id @default(cuid())
  title         String
  content       String
  authorId      String
  category      String   // "healing-experiences", "spiritual-growth", "questions-answers", etc.
  tags          String? // JSON string of tag array
  isPinned      Boolean  @default(false)
  isLocked      Boolean  @default(false)
  isHidden      Boolean  @default(false) // For moderation
  likesCount    Int      @default(0)
  commentsCount Int      @default(0)
  viewsCount    Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  author   User           @relation("ForumPostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  comments ForumComment[]
  likes    ForumPostLike[]

  @@map("forum_posts")
}

model ForumComment {
  id        String   @id @default(cuid())
  postId    String
  authorId  String
  content   String
  parentId  String?  // For nested replies
  isHidden  Boolean  @default(false) // For moderation
  likesCount Int     @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post     ForumPost          @relation(fields: [postId], references: [id], onDelete: Cascade)
  author   User               @relation("ForumCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  parent   ForumComment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  ForumComment[]     @relation("CommentReplies")
  likes    ForumCommentLike[]

  @@map("forum_comments")
}

model ForumPostLike {
  id     String @id @default(cuid())
  postId String
  userId String
  createdAt DateTime @default(now())

  post ForumPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId]) // Prevent duplicate likes
  @@map("forum_post_likes")
}

model ForumCommentLike {
  id        String @id @default(cuid())
  commentId String
  userId    String
  createdAt DateTime @default(now())

  comment ForumComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId]) // Prevent duplicate likes
  @@map("forum_comment_likes")
}

